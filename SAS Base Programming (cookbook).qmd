---
title: SAS 9.4 BASE PROGRAMMING - THE EXAM COOKBOOK
---

INTRODUCTION
------------

### SAS, and why it matters

***SAS (Statistical Analysis System)*** has been a cornerstone of data analysis for over half a century. Unlike many programming languages that rise and fall in popularity, SAS has maintained a consistent, stable presence in industries where precision and compliance are non‚Äënegotiable ‚Äî particularly pharmaceutical research, clinical trials, and regulatory reporting.

Strictly speaking, ***SAS*** itself is not just one programming language, but a comprehensive data management and analytics platform.

Inside **SAS**, there are **multiple programming languages**:

- DATA Step (for data manipulation)
- PROC (to call procedures like PROC MEANS)
- Macro (for automation and dynamic code)
- SQL/FedSQL (relational queries)
- DS2 (an object‚Äëoriented data step extension)
- IML (Interactive Matrix Language) (for advanced stats)
- SCL (Screen Control Language) (for UI stuff)

**SAS** has several modules but it is mainly divided into 3 sections: 

- SAS Base = DATA Step + PROC
- SAS Advanced 
- SAS Statistics
 
***SAS OnDemand for Academics (SODA)*** is a free web-based version of SAS allowing you to access SAS without requiring installation of SAS on your computer. The default integrated development environment (IDE) for SODA is ***SAS Studio***.

### Anatomy of a SAS Base program

Each block (***step***) starts with DATA or PROC and ends with `RUN;`.
Use `QUIT;` for some processes (e.g., PROC SQL).

```{sas}
data library.dataset;        * The step starts;
    set library.source;      * Brings in existing data (optional);
    input var1 var2 $ var3;  * Defines variables for new data (optional);
    datalines;               * Inlines data (optional);
value1 value2 value3
...
;
run;                         * The step ends;
```

```{sas}
proc <procedure_name> data = <library.dataset>;  * The step starts;
    var var1 var2;                               * Selects variables;
    title "Report title";                        * Optional title;
run;                                             * The step ends;
```

### Default SODA writable libraries and files

- ***`work`*** - temporary: default location for new datasets if no library is specified
- ***user-defined libraries*** (e.g., `mylib`): custom libraries assigned using LIBNAME to point to a chosen folder; persist as long as the folder exists, but need to be reassigned in each new session (unless included in `autoexec.sas`)
- ***autoexec.sas***: a special SAS program that runs automatically each time SAS starts; it is typically used to assign libraries, set global options, load macros or other frequently used code  

Exam tip: In the exam environment, you will likely need to reassign libraries manually ‚Äî don‚Äôt rely on autoexec.sas.

***

PART A. ACCESS AND CREATE DATA STRUCTURES (20-25%)
--------------------------------------------------

## 1. Create temporary and permanent SAS data sets

SAS data sets can be ***temporary*** (session‚Äëonly) or ***permanent*** (saved for later use).

### Temporary data set

If no library is specified, a data set is automatically stored as temporary in the `work` library. It is erased when the SAS session ends.

```{sas}
data class_temp;
    set sashelp.class;
run;
```

### Permanent data set

To keep a data set for future use, store it in a permanent library by assigning a library reference with LIBNAME.

```{sas}
libname mylib "/home/username/myfolder";    * Assigns a permanent library `mylib`;

data mylib.class_perm;
    set sashelp.class;
run;
```

Exam tip: Use a two‚Äëlevel name: libref.dataset. The folder path must exist before you assign the library.

### Viewing libraries and data sets

To see all data sets inside a library:

```{sas}
proc contents data = mylib._all_;
run;
```

***

## 2. Investigate SAS data libraries using base SAS utility procedures

***SAS libraries***: the essential containers for storing and managing data sets.

### Assigning a library using LIBNAME

To access or create data sets in a specific directory (or server folder), use the LIBNAME statement to assign a library reference (`libref`).

```{sas}
libname examlib "/home/u64285960/examdata";    * `examlib` is the libref (can be up to 8 characters);
```

The quoted path must exist and be accessible.

Use when you want to save or read permanent data sets ‚Äî outside the volatile WORK library.

### Viewing library contents with PROC CONTENTS

To examine the structure of a library or its data sets, use PROC CONTENTS.

To list **all data** sets in a library:

```{sas}
proc contents data = examlib._all_ nods;
run;
```

_ALL_ shows all data sets in the library.

NODS suppresses printing full variable details for each data set.

To explore a **single data set**:

```{sas}
proc contents data = examlib.heart_perm;
run;
```

Shows variable names, types, lengths, labels, and creation/modification metadata.

Very useful to understand the structure and metadata before processing the data set.

***

## 3. Access data

This chapter covers how to bring both SAS and non-SAS data into your program: how to read permanent or temporary SAS datasets, and how to import external files like .xlsx or .csv.

### Access SAS datasets with SET

The SET statement reads observations from one or more SAS datasets into a DATA step.

```{sas}
data work.new_data;
    set sashelp.class;
run;
```

Commonly used for copying or modifying existing SAS data.

### Importing non-SAS datasets with PROC IMPORT

PROC IMPORT reads delimited text files, .csv, and .xlsx workbooks.

```{sas}
proc import datafile = "/home/user/data/students.xlsx"
    out = work.students
    dbms = xlsx
    replace;
run;
```

OUT = ‚Üí name of the output SAS dataset.

DBMS = ‚Üí type of source file (.xlsx, .csv, .tab, etc.).

REPLACE ‚Üí overwrite if dataset already exists.

### GUESSINGROWS option

Tells SAS how many rows to scan to determine variable types/lengths.

```{sas}
proc import datafile = "/home/user/data/students.csv"
    out = work.students
    dbms = csv
    replace;
    guessingrows = 500;
run;
```

Use when columns may have mixed content or the first few rows aren‚Äôt representative.

### DELIMITER option

Specifies the character separating values in a delimited text file.

```{sas}
proc import datafile = "/home/user/data/students.txt"
    out = work.students
    dbms = dlim
    replace;
    delimiter = '|';
run;
```

### SAS/ACCESS XLSX engine

Lets you treat an uploaded Excel workbook as a SAS library. Enables reading, writing, and listing sheets like SAS datasets.

```{sas}
libname myxlsx xlsx "/home/user/data/students.xlsx";

proc contents data = myxlsx._all_;
run;

libname myxlsx clear;    *Detaches (unassigns) the library reference named myxlsx.;
```

***

## 4. Combine SAS data sets

In SAS, **combining datasets** allows you to bring together observations or variables from different sources. The main methods are:

- ***concatenation*** ‚Äì stacking datasets *vertically* (adding observations)

- ***merging one-to-one*** ‚Äì combining datasets *horizontally* (matching observations one-to-one)

- ***merging one-to-many*** ‚Äì combining datasets where one dataset contains multiple matches for a key in the other.

### Concatenate datasets

Datasets must have the same variable names and types for direct stacking; otherwise, SAS creates missing values for variables absent in some datasets.

```{sas}
data combined;
    set sales_q1 sales_q2;
run;   /* Adds all rows from SALES_Q1 followed by all rows from SALES_Q2 */
```

### Merge datasets one-to-one

One-to-one merge combines datasets horizontally by matching rows in order (no BY statement) or by key variables (with BY statement). Both datasets must be sorted by the key if using BY.

```{sas}
data merged_1to1;
    merge customers orders;
    by customer_id;
run;    /* Each CUSTOMER_ID from both datasets matched one-to-one */
```

### Merge data sets one-to-many

One-to-many merge matches each row in one dataset with all matching rows in another. The ‚Äúmany‚Äù dataset has multiple rows per key, while the ‚Äúone‚Äù dataset has only one.

```{sas}
proc sort data = customers; by customer_id; run;
proc sort data = transactions; by customer_id; run;

data merged_1toM;
    merge customers transactions;
    by customer_id;
run;    /* Each CUSTOMER_ID in CUSTOMERS matched to all its TRANSACTIONS */
```

***

## 5. Create and manipulate SAS date values

SAS stores dates/times as numbers (dates = days since 01JAN1960; times = seconds since midnight; datetimes = seconds since 01JAN1960 00:00:00). You‚Äôll use literals, informats (INPUT), and formats/output (FORMAT) to read and display them correctly.

### Understanding formats vs informats

***Informat***: tells SAS how to read raw text into an internal value (used by INPUT). 

***Format***: tells SAS how to display a stored value (used by FORMAT or in PROCs).

Common SAS date/time formats and informats:

- **`date9.`** - "15AUG1998" - classic ddMONyyyy form, 9 chars
- `mmddyy10.`	- "08/15/1998" - US style with slashes, 10 chars
- `ddmmyy10.`	- "15/08/1998" - day first (European style)
- `worddate.`	- "August 15, 1998" - words, no leading zeros
- **`time8.`** - "09:45:00"	- hours:minutes:seconds
- `hhmm.` - "09:45" - hours and minutes only
- **`datetime20.`** - "15AUG1998:09:45:00" - date + time, 20 chars
- `dtmonyy.` - "Aug98" (with time if formatted) - abbrev. month + year
- `dateampm.` - "15AUG1998:9:45:00 AM" - date/time with AM/PM

üí° Exam tip: These names are permanent in SAS. Case doesn‚Äôt matter (`DATE9.` = `date9.`), but the period is required.

```{sas}
/* read raw date text with an informat */
input birth_date date9.;

/* display a stored date with a format */
format birth_date worddate.;
```

Always pair the right informat for reading and a suitable format for display.

### How SAS stores date and time values

Date/time/datetime are numeric internally; ***literals*** let you hard-code constants in your code.

```{sas}
data work.example;
    start_date   = '01jan2025'd;               /* date literal */
    opening_time = '12:30:00't;                /* time literal */
    event_start  = '01jan2025:12:30:00'dt;     /* datetime literal */
run;
```

Literals give stable, reproducible cutoffs and example data (vs NOW via functions).

### Using SAS informats to read date/time expressions (input)

Place **informats** on variables in INPUT statement so SAS interprets raw text correctly.

```{sas}
data work.example2;
    input dob date9. appt time8. dt datetime20.;
    format dob date9. appt time8. dt datetime20.;    /* output look */
    datalines;
01JAN2020 14:35:20 01JAN2020:14:35:20
;
run;
```

Without the right informat, dates/times remain character and you can‚Äôt do date math.

### Using SAS formats to display date/time values (output)

**Formats** change the appearance without changing the stored value.

```{sas}
data work.example3;
    today = today();       /* numeric date (days since 1960) */
    now   = datetime();    /* numeric datetime (seconds)     */
    format today mmddyy10. now datetime20.;
run;
```

Switch formats anytime to match reporting needs (e.g., DATE9., WORDDATE., DATEAMPM.).

***

## 6. Control which observations and variables are processed and output

***PDV conveyor-belt model*** (one picture to remember):

- Gate = WHERE (pre-PDV): rows admitted or blocked before they enter the workspace.
- Workbench = DATA/SET + calculations: row is in memory; you compute.
- Trash chute = `IF ‚Ä¶ THEN DELETE` / IF condition (post-PDV): drop the row after you‚Äôve seen it.
- Parts bins = `KEEP =`/`DROP =` on input (`set ds (keep = ‚Ä¶ drop = ‚Ä¶)`): which columns are brought into the PDV.
- Box sealer = KEEP/DROP statement or `KEEP =`/`DROP =` on output: which columns leave the step.

**Four-question decision tree** (use before every DATA step):

1) Which table(s) feed the step? ‚Üí SET (or MERGE + BY).
2) Row rule?
    - Only existing columns? ‚Üí WHERE (or `WHERE =`).
    - Needs a computed flag from this step? ‚Üí IF.
3) Columns needed during processing? ‚Üí KEEP=/DROP= on input.
4) Columns to publish in output? ‚Üí KEEP/DROP statement or KEEP=/DROP= on DATA target (pick one).

Minimal templates (copy ‚Üí tweak):

- pre-filter + limit columns read (fast path):

```{sas}
data work.out (keep = vars_you_publish);
    set lib.in (keep = cols_needed where = (your_where_condition));
    /* compute here */
run;
```

- computed condition (post-PDV IF):

```{sas}
data work.out;
    set lib.in (keep = vars_needed);
    flag = (/* expression */);
    if flag;    /* or: if not flag then delete; */
run;
```

- target one source (`WHERE =`) in a merge:

```{sas}
data work.out;
    merge a (keep = ... where = (...))
          b (keep = ... );
    by id;
    if /* row rule */;
run;
```

### WHERE vs IF (quick rules)

WHERE - pre-PDV; faster; usable in PROCs; cannot reference variables created later in the same step.

IF - post-PDV; can use computed variables; works only in DATA steps.

### KEEP/DROP vs `KEEP =`/`DROP =`

KEEP/DROP statements ‚Üí control output only (all inputs still available while computing).

`KEEP =`/`DROP =` on input ‚Üí reduces columns brought into PDV (can speed I/O).

`KEEP =`/`DROP =` on output ‚Üí limits columns saved at creation time.

### `WHERE =` option (surgical filtering)

Put `WHERE =` on a specific input in SET/MERGE to filter that source only.

### Gotchas / smell tests

WHERE can‚Äôt see variables created later in the same DATA step ‚Üí use IF instead.

PROCs use WHERE, not IF.

‚ÄúVariable not found‚Äù during compute ‚Üí you probably dropped it on input (`KEEP =` too aggressive).

Don‚Äôt mix KEEP and DROP for the same target ‚Äî pick one.

Prefer WHERE inside PROCs; use IF only when you must filter on computed values.

Handy predicates you‚Äôll reuse:

```{sas}
where upcase(sex) = 'F';
where name like 'A%';             /* starts with A */
where age between 12 and 15;      /* inclusive */
where name ? 'nn';                /* contains substring */
if missing (height) then delete;  /* drop rows with missing height */
```

***









































## 6. Control which observations and variables in a SAS data set are processed and output

‚Ä¢  Use the WHERE and IF statements in the DATA step to select observations to be processed.
‚Ä¢  Subset variables to be output by using the DROP and KEEP statements.
‚Ä¢  Use the DROP= and KEEP= data set options to specify columns to be processed and/or output.

***

PART B. MANAGE DATA (35-40%)
----------------------------

## 7. Sort observations in a SAS data set

‚Ä¢ Use the SORT Procedure to re-order observations in place or output to a new dataset with the OUT= option.
‚Ä¢ Remove duplicate observations with the SORT Procedure.

## 8. Conditionally execute SAS statements

‚Ä¢ Use IF-THEN/ELSE statements to process data conditionally.
‚Ä¢ Use DO and END statements to execute multiple statements conditionally.

## 9. Use assignment statements in the DATA step

‚Ä¢ Create new variables and assign a value.
‚Ä¢ Assign a new value to an existing variable.
‚Ä¢ Assign the value of an expression to a variable.
‚Ä¢ Assign a constant date value to a variable.

## 10. Modify variable attributes using options and statements in the DATA step

‚Ä¢ Change the names of variables by using the RENAME= data set option.
‚Ä¢ Use LABEL and FORMAT statements to modify attributes in a DATA step.
‚Ä¢ Define the length of a variable using the LENGTH statement.

## 11.Accumulate sub-totals and totals using DATA step statements

‚Ä¢ Use the BY statement to aggregate by subgroups.
‚Ä¢ Use first. and last. processing to identify where groups begin and end.
‚Ä¢ Use the RETAIN and SUM statements.

## 12. Use SAS functions to manipulate character data, numeric data, and SAS date values

‚Ä¢ Use SAS functions such as SCAN, SUBSTR, TRIM, COMPRESS, UPCASE, and LOWCASE to perform tasks such as the tasks shown below.

    o Replace the contents of a character value.
    o Remove unwanted characters from strings.
    o Search a character value and extract a portion of the value.
    o Convert a character value to upper or lowercase.

‚Ä¢ Use SAS numeric functions such as SUM, MEAN, RAND, SMALLEST, LARGEST, ROUND, and INT.
‚Ä¢ Create SAS date values by using the functions MDY, TODAY, DATE, and TIME.
‚Ä¢ Extract the month, year, and interval from a SAS date value by using the functions YEAR, QTR, MONTH, and DAY.
‚Ä¢ Perform calculations with date and datetime values and time intervals by using the functions INTCK, INTNX, and YRDIF.
‚Ä¢ Use variable lists to efficiently reference multiple variables (OF operator, :,-,--).

## 13. Use SAS functions to convert character data to numeric and vice versa

‚Ä¢ Explain the automatic conversion that SAS uses to convert values between data types.
‚Ä¢ Use the INPUT function to explicitly convert character data values to numeric values.
‚Ä¢ Use the PUT function to explicitly convert numeric data values to character values.

## 14. Process data using DO LOOPS

‚Ä¢ Explain how iterative DO loops function.
‚Ä¢ Use DO loops to eliminate redundant code and to perform repetitive calculations.
‚Ä¢ Use conditional DO loops.
‚Ä¢ Use nested DO loops.

## 15. Restructure SAS data sets with PROC TRANSPOSE

‚Ä¢ Select variables to transpose with the VAR statement.
‚Ä¢ Rename transposed variables with the ID statement.
‚Ä¢ Process data within groups using the BY statement.
‚Ä¢ Use PROC TRANSPOSE options (OUT=, PREFIX= and NAME=).

## 16. Use macro variables to simplify program maintenance

‚Ä¢ Create macro variables with the %LET statement.
‚Ä¢ Use macro variables within SAS programs.
‚Ä¢ Use the macro variable name dot delimiter (.)

***

PART C. ERROR HANDLING (15-20%)
-------------------------------

## 17. Identify and resolve programming logic errors

‚Ä¢ Use the PUTLOG Statement in the Data Step to help identify logic errors.
‚Ä¢ Use PUTLOG to write the value of a variable, formatted values, or to write values of all variables.
‚Ä¢ Use PUTLOG with Conditional logic.
‚Ä¢ Use temporary variables N and ERROR to debug a DATA step.

## 18. Recognize and correct syntax errors

‚Ä¢ Identify the characteristics of SAS statements.
‚Ä¢ Define SAS syntax rules including the typical types of syntax errors such as misspelled keywords, unmatched quotation marks, missing semicolons, and invalid options.
‚Ä¢ Use the log to help diagnose syntax errors in a given program.

***

PART D. GENERATE REPORTS AND OUTPUT (15-20%)
--------------------------------------------

## 19. Generate list reports using the PRINT procedure

‚Ä¢ Modify the default behavior of PROC PRINT by adding statements and options such as

    o use the VAR statement to select and order variables.
    o calculate totals with a SUM statement.
    o select observations with a WHERE statement.
    o use the ID statement to identify observations.
    o use the BY statement to process groups.
    o use the NOOBS and LABEL options.

## 20. Generate summary reports and frequency tables using base SAS procedures

‚Ä¢ Produce one-way and two-way frequency tables with the FREQ procedure.
‚Ä¢ Enhance frequency tables with options (NLEVELS, ORDER=).
‚Ä¢ Use PROC FREQ to validate data in a SAS data set.
‚Ä¢ Calculate summary statistics and multilevel summaries using the MEANS procedure.

    o WAYS, CLASS, VAR, OUTPUT statements

‚Ä¢ Enhance summary tables with options.
‚Ä¢ Identify extreme and missing values with the UNIVARIATE procedure.

## 21. Enhance reports using user-defined formats, titles, footnotes, and SAS System reporting options

‚Ä¢ Use PROC FORMAT to define custom formats.

    o VALUE statement
    o CNTLIN= option

‚Ä¢ Use the LABEL statement to define descriptive column headings.
‚Ä¢ Control the use of column headings with the LABEL and SPLIT=options in PROC PRINT output.

## 22. Generate reports using ODS statements

‚Ä¢ Identify the Output Delivery System destinations.
‚Ä¢ Create HTML, PDF, RTF, XLSX, and PPTX files with ODS statements.
‚Ä¢ Use the STYLE=option to specify a style template.
‚Ä¢ Generate comma separated value (CSV) files with ODS statements.

## 23. Export data

‚Ä¢ Create a simple raw data file by using the EXPORT procedure as an alternative to the DATA step.

    o Control the export file format with common DBMS identifiers: (csv, jmp, tab, dlm).

‚Ä¢ Export data to Microsoft Excel using the SAS/ACCESS XLSX engine.






















